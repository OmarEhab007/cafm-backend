package com.cafm.cafmbackend.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.UUID;

import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Security vulnerability tests for all API endpoints.
 * Tests for OWASP Top 10 vulnerabilities and common security issues.
 */
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
@ActiveProfiles("test")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@DisplayName("Security Vulnerability Tests")
class SecurityVulnerabilityTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
            .withDatabaseName("cafm_test")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void properties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    // ========== SQL Injection Tests ==========

    @Test
    @Order(1)
    @DisplayName("Should prevent SQL injection in login")
    void testSQLInjection_Login() throws Exception {
        String sqlInjectionPayload = """
                {
                    "email": "admin@test.com' OR '1'='1' --",
                    "password": "' OR '1'='1"
                }
                """;

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(sqlInjectionPayload)
                        .with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @Order(2)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should prevent SQL injection in search parameters")
    void testSQLInjection_SearchParams() throws Exception {
        String maliciousSearch = "'; DROP TABLE users; --";

        mockMvc.perform(get("/api/v1/users")
                        .param("search", maliciousSearch))
                .andExpect(status().isOk()); // Should handle safely without executing SQL
    }

    @Test
    @Order(3)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should prevent SQL injection in ID parameters")
    void testSQLInjection_IdParameter() throws Exception {
        String maliciousId = "' OR '1'='1";

        mockMvc.perform(get("/api/v1/users/" + maliciousId))
                .andExpect(status().isBadRequest());
    }

    // ========== XSS (Cross-Site Scripting) Tests ==========

    @Test
    @Order(4)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should sanitize XSS in user input")
    void testXSS_UserCreation() throws Exception {
        String xssPayload = """
                {
                    "email": "test@example.com",
                    "password": "Password123!",
                    "firstName": "<script>alert('XSS')</script>",
                    "lastName": "<img src=x onerror=alert('XSS')>",
                    "userType": "TECHNICIAN",
                    "companyId": "%s"
                }
                """.formatted(UUID.randomUUID());

        mockMvc.perform(post("/api/v1/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(xssPayload)
                        .with(csrf()))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.firstName").value(not(containsString("<script>"))));
    }

    @Test
    @Order(5)
    @WithMockUser(roles = "SUPERVISOR")
    @DisplayName("Should prevent XSS in report creation")
    void testXSS_ReportCreation() throws Exception {
        String xssPayload = """
                {
                    "title": "<script>alert('XSS')</script>",
                    "description": "javascript:alert('XSS')",
                    "priority": "HIGH",
                    "category": "HVAC",
                    "schoolId": "%s",
                    "location": "<iframe src='evil.com'></iframe>"
                }
                """.formatted(UUID.randomUUID());

        mockMvc.perform(post("/api/v1/reports")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(xssPayload)
                        .with(csrf()))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.title").value(not(containsString("<script>"))));
    }

    // ========== CSRF (Cross-Site Request Forgery) Tests ==========

    @Test
    @Order(6)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should block requests without CSRF token")
    void testCSRF_MissingToken() throws Exception {
        String validRequest = """
                {
                    "email": "test@example.com",
                    "password": "Password123!"
                }
                """;

        // Without CSRF token
        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(validRequest))
                .andExpect(status().isForbidden());
    }

    @Test
    @Order(7)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should accept requests with valid CSRF token")
    void testCSRF_ValidToken() throws Exception {
        String validRequest = """
                {
                    "email": "test@example.com",
                    "password": "Password123!"
                }
                """;

        // With CSRF token
        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(validRequest)
                        .with(csrf()))
                .andExpect(status().is5xxServerError()); // Will fail at service level, but CSRF passes
    }

    // ========== Authentication & Authorization Tests ==========

    @Test
    @Order(8)
    @DisplayName("Should require authentication for protected endpoints")
    void testAuth_RequireAuthentication() throws Exception {
        mockMvc.perform(get("/api/v1/users"))
                .andExpect(status().isUnauthorized());

        mockMvc.perform(get("/api/v1/companies"))
                .andExpect(status().isUnauthorized());

        mockMvc.perform(get("/api/v1/reports"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @Order(9)
    @WithMockUser(roles = "TECHNICIAN")
    @DisplayName("Should enforce role-based access control")
    void testAuth_RoleBasedAccess() throws Exception {
        // Technician should not access admin endpoints
        mockMvc.perform(get("/api/v1/users"))
                .andExpect(status().isForbidden());

        mockMvc.perform(post("/api/v1/companies")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{}")
                        .with(csrf()))
                .andExpect(status().isForbidden());
    }

    @Test
    @Order(10)
    @WithMockUser(roles = "ADMIN", username = "admin@companya.com")
    @DisplayName("Should enforce tenant isolation")
    void testAuth_TenantIsolation() throws Exception {
        // Admin from Company A should not access Company B data
        UUID companyBId = UUID.randomUUID();

        mockMvc.perform(get("/api/v1/companies/" + companyBId))
                .andExpect(status().isForbidden());
    }

    // ========== Input Validation Tests ==========

    @Test
    @Order(11)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should validate email format")
    void testValidation_EmailFormat() throws Exception {
        String invalidEmail = """
                {
                    "email": "not-an-email",
                    "password": "Password123!",
                    "firstName": "Test",
                    "lastName": "User",
                    "userType": "TECHNICIAN",
                    "companyId": "%s"
                }
                """.formatted(UUID.randomUUID());

        mockMvc.perform(post("/api/v1/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(invalidEmail)
                        .with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @Order(12)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should enforce password complexity")
    void testValidation_PasswordComplexity() throws Exception {
        String weakPassword = """
                {
                    "email": "test@example.com",
                    "password": "weak",
                    "firstName": "Test",
                    "lastName": "User",
                    "userType": "TECHNICIAN",
                    "companyId": "%s"
                }
                """.formatted(UUID.randomUUID());

        mockMvc.perform(post("/api/v1/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(weakPassword)
                        .with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @Order(13)
    @WithMockUser(roles = "ADMIN")
    @DisplayName("Should validate UUID format")
    void testValidation_UUIDFormat() throws Exception {
        String invalidUUID = "not-a-uuid";

        mockMvc.perform(get("/api/v1/users/" + invalidUUID))
                .andExpect(status().isBadRequest());
    }

    // ========== Rate Limiting Tests ==========

    @Test
    @Order(14)
    @DisplayName("Should rate limit login attempts")
    void testRateLimiting_LoginAttempts() throws Exception {
        String loginRequest = """
                {
                    "email": "test@example.com",
                    "password": "WrongPassword"
                }
                """;

        // Simulate multiple failed login attempts
        for (int i = 0; i < 10; i++) {
            mockMvc.perform(post("/api/v1/auth/login")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(loginRequest)
                            .with(csrf()))
                    .andExpect(status().is5xxServerError());
        }

        // After threshold, should be rate limited
        // In production, this would return 429 Too Many Requests
    }

    // ========== Information Disclosure Tests ==========

    @Test
    @Order(15)
    @DisplayName("Should not leak sensitive information in errors")
    void testInfoDisclosure_ErrorMessages() throws Exception {
        mockMvc.perform(get("/api/v1/users/" + UUID.randomUUID()))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.stackTrace").doesNotExist())
                .andExpect(jsonPath("$.sql").doesNotExist());
    }

    @Test
    @Order(16)
    @DisplayName("Should not enumerate valid emails")
    void testInfoDisclosure_EmailEnumeration() throws Exception {
        String validEmailRequest = """
                {
                    "email": "existing@example.com"
                }
                """;

        String invalidEmailRequest = """
                {
                    "email": "nonexistent@example.com"
                }
                """;

        // Both should return same generic message
        mockMvc.perform(post("/api/v1/auth/forgot-password")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(validEmailRequest)
                        .with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Check your email for reset instructions"));

        mockMvc.perform(post("/api/v1/auth/forgot-password")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(invalidEmailRequest)
                        .with(csrf()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Check your email for reset instructions"));
    }

    // ========== File Upload Security Tests ==========

    @Test
    @Order(17)
    @WithMockUser(roles = "SUPERVISOR")
    @DisplayName("Should validate file types in upload")
    void testFileUpload_ValidateType() throws Exception {
        // Test with executable file
        mockMvc.perform(multipart("/api/v1/files/upload")
                        .file("file", "malicious.exe", "executable content".getBytes())
                        .with(csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    @Order(18)
    @WithMockUser(roles = "SUPERVISOR")
    @DisplayName("Should enforce file size limits")
    void testFileUpload_SizeLimit() throws Exception {
        // Create large file (>10MB)
        byte[] largeFile = new byte[11 * 1024 * 1024];
        
        mockMvc.perform(multipart("/api/v1/files/upload")
                        .file("file", "large.jpg", largeFile)
                        .with(csrf()))
                .andExpect(status().isPayloadTooLarge());
    }

    // ========== JWT Security Tests ==========

    @Test
    @Order(19)
    @DisplayName("Should reject expired JWT tokens")
    void testJWT_ExpiredToken() throws Exception {
        String expiredToken = "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0QGV4YW1wbGUuY29tIiwiaWF0IjoxNjAwMDAwMDAwLCJleHAiOjE2MDAwMDAwMDF9.invalid";

        mockMvc.perform(get("/api/v1/users/profile")
                        .header("Authorization", expiredToken))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @Order(20)
    @DisplayName("Should reject tampered JWT tokens")
    void testJWT_TamperedToken() throws Exception {
        String tamperedToken = "Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbkBleGFtcGxlLmNvbSIsInJvbGUiOiJTVVBFUl9BRE1JTiJ9.tampered";

        mockMvc.perform(get("/api/v1/users/profile")
                        .header("Authorization", tamperedToken))
                .andExpect(status().isUnauthorized());
    }

    // ========== Headers Security Tests ==========

    @Test
    @Order(21)
    @WithMockUser(roles = "USER")
    @DisplayName("Should include security headers in responses")
    void testSecurityHeaders() throws Exception {
        mockMvc.perform(get("/api/v1/users/profile"))
                .andExpect(header().exists("X-Content-Type-Options"))
                .andExpect(header().string("X-Content-Type-Options", "nosniff"))
                .andExpect(header().exists("X-Frame-Options"))
                .andExpect(header().string("X-Frame-Options", "DENY"))
                .andExpect(header().exists("X-XSS-Protection"))
                .andExpect(header().string("X-XSS-Protection", "1; mode=block"));
    }

    // ========== Business Logic Security Tests ==========

    @Test
    @Order(22)
    @WithMockUser(roles = "TECHNICIAN", username = "tech@example.com")
    @DisplayName("Should prevent unauthorized work order completion")
    void testBusinessLogic_UnauthorizedCompletion() throws Exception {
        UUID otherTechWorkOrder = UUID.randomUUID();
        
        String completionRequest = """
                {
                    "resolution": "Fixed",
                    "actualCost": 100.00
                }
                """;

        mockMvc.perform(post("/api/v1/work-orders/" + otherTechWorkOrder + "/complete")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(completionRequest)
                        .with(csrf()))
                .andExpect(status().isForbidden());
    }

    @Test
    @Order(23)
    @WithMockUser(roles = "SUPERVISOR")
    @DisplayName("Should prevent negative cost values")
    void testBusinessLogic_NegativeValues() throws Exception {
        String invalidRequest = """
                {
                    "title": "Test Work Order",
                    "description": "Test",
                    "priority": "HIGH",
                    "estimatedCost": -100.00
                }
                """;

        mockMvc.perform(post("/api/v1/work-orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(invalidRequest)
                        .with(csrf()))
                .andExpect(status().isBadRequest());
    }

    // Helper method
    private String containsString(String substring) {
        return org.hamcrest.Matchers.containsString(substring);
    }

    private String not(String matcher) {
        return org.hamcrest.Matchers.not(matcher);
    }
}