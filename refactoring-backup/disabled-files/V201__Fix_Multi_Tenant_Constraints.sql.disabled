-- ============================================
-- V201__Fix_Multi_Tenant_Constraints.sql  
-- CRITICAL SECURITY FIX: Replace global unique constraints with tenant-scoped constraints
-- ============================================

-- ============================================
-- STEP 1: ANALYZE CURRENT CONSTRAINT ISSUES
-- ============================================

-- Log current problematic constraints
DO $$
DECLARE
    constraint_record RECORD;
BEGIN
    RAISE NOTICE '=== ANALYZING MULTI-TENANT CONSTRAINT VIOLATIONS ===';
    
    -- Check for global unique constraints that conflict with multi-tenancy
    FOR constraint_record IN
        SELECT 
            tc.constraint_name,
            tc.table_name,
            kcu.column_name
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage kcu 
            ON tc.constraint_name = kcu.constraint_name
        WHERE tc.constraint_type = 'UNIQUE' 
        AND tc.table_schema = 'public'
        AND tc.table_name IN ('users', 'schools', 'companies', 'reports', 'work_orders', 'assets')
        AND kcu.column_name IN ('email', 'username', 'employee_id', 'code', 'domain', 'subdomain', 'report_number')
    LOOP
        RAISE NOTICE 'Found problematic global constraint: % on %.%', 
                     constraint_record.constraint_name, 
                     constraint_record.table_name, 
                     constraint_record.column_name;
    END LOOP;
END $$;

-- ============================================
-- STEP 2: DROP PROBLEMATIC GLOBAL UNIQUE CONSTRAINTS
-- ============================================

-- Drop global unique constraint on users.email
DO $$
BEGIN
    -- Find and drop the email unique constraint
    IF EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE table_name = 'users' 
        AND constraint_type = 'UNIQUE'
        AND constraint_name LIKE '%email%'
    ) THEN
        -- Drop existing unique constraint on email
        ALTER TABLE users DROP CONSTRAINT IF EXISTS users_email_key;
        ALTER TABLE users DROP CONSTRAINT IF EXISTS uk_users_email;
        ALTER TABLE users DROP CONSTRAINT IF EXISTS uq_users_email;
        RAISE NOTICE 'Dropped global unique constraint on users.email';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not drop email constraint: %', SQLERRM;
END $$;

-- Drop global unique constraint on users.username
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE table_name = 'users' 
        AND constraint_type = 'UNIQUE'
        AND constraint_name LIKE '%username%'
    ) THEN
        ALTER TABLE users DROP CONSTRAINT IF EXISTS users_username_key;
        ALTER TABLE users DROP CONSTRAINT IF EXISTS uk_users_username;
        ALTER TABLE users DROP CONSTRAINT IF EXISTS uq_users_username;
        RAISE NOTICE 'Dropped global unique constraint on users.username';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not drop username constraint: %', SQLERRM;
END $$;

-- Drop global unique constraint on users.employee_id
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE table_name = 'users' 
        AND constraint_type = 'UNIQUE'
        AND constraint_name LIKE '%employee_id%'
    ) THEN
        ALTER TABLE users DROP CONSTRAINT IF EXISTS users_employee_id_key;
        ALTER TABLE users DROP CONSTRAINT IF EXISTS uk_users_employee_id;
        ALTER TABLE users DROP CONSTRAINT IF EXISTS uq_users_employee_id;
        RAISE NOTICE 'Dropped global unique constraint on users.employee_id';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not drop employee_id constraint: %', SQLERRM;
END $$;

-- Drop global unique constraint on schools.code
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE table_name = 'schools' 
        AND constraint_type = 'UNIQUE'
        AND constraint_name LIKE '%code%'
    ) THEN
        ALTER TABLE schools DROP CONSTRAINT IF EXISTS schools_code_key;
        ALTER TABLE schools DROP CONSTRAINT IF EXISTS uk_schools_code;
        ALTER TABLE schools DROP CONSTRAINT IF EXISTS uq_schools_code;
        RAISE NOTICE 'Dropped global unique constraint on schools.code';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not drop school code constraint: %', SQLERRM;
END $$;

-- Drop global unique constraint on reports.report_number  
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE table_name = 'reports' 
        AND constraint_type = 'UNIQUE'
        AND constraint_name LIKE '%report_number%'
    ) THEN
        ALTER TABLE reports DROP CONSTRAINT IF EXISTS reports_report_number_key;
        ALTER TABLE reports DROP CONSTRAINT IF EXISTS uk_reports_report_number;
        ALTER TABLE reports DROP CONSTRAINT IF EXISTS uq_reports_report_number;
        RAISE NOTICE 'Dropped global unique constraint on reports.report_number';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not drop report_number constraint: %', SQLERRM;
END $$;

-- ============================================
-- STEP 3: CREATE TENANT-SCOPED UNIQUE CONSTRAINTS
-- ============================================

-- Create tenant-scoped unique constraint for users.email
DO $$
BEGIN
    -- Ensure company_id column exists
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'users' AND column_name = 'company_id'
    ) THEN
        -- Create tenant-scoped unique constraint
        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_users_email_company_unique 
        ON users (company_id, LOWER(email)) 
        WHERE deleted_at IS NULL;
        
        RAISE NOTICE 'Created tenant-scoped unique constraint for users.email';
    ELSE
        RAISE NOTICE 'Cannot create tenant constraint: users.company_id column does not exist';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not create tenant email constraint: %', SQLERRM;
END $$;

-- Create tenant-scoped unique constraint for users.username
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'users' AND column_name = 'company_id'
    ) THEN
        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_users_username_company_unique 
        ON users (company_id, LOWER(username)) 
        WHERE deleted_at IS NULL;
        
        RAISE NOTICE 'Created tenant-scoped unique constraint for users.username';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not create tenant username constraint: %', SQLERRM;
END $$;

-- Create tenant-scoped unique constraint for users.employee_id
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'users' AND column_name = 'company_id'
    ) AND EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'users' AND column_name = 'employee_id'
    ) THEN
        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_users_employee_id_company_unique 
        ON users (company_id, employee_id) 
        WHERE deleted_at IS NULL AND employee_id IS NOT NULL;
        
        RAISE NOTICE 'Created tenant-scoped unique constraint for users.employee_id';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not create tenant employee_id constraint: %', SQLERRM;
END $$;

-- Create tenant-scoped unique constraint for schools.code
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'schools' AND column_name = 'company_id'
    ) THEN
        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_schools_code_company_unique 
        ON schools (company_id, code) 
        WHERE deleted_at IS NULL;
        
        RAISE NOTICE 'Created tenant-scoped unique constraint for schools.code';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not create tenant school code constraint: %', SQLERRM;
END $$;

-- Create tenant-scoped unique constraint for reports.report_number
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'reports' AND column_name = 'company_id'
    ) THEN
        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_reports_report_number_company_unique 
        ON reports (company_id, report_number) 
        WHERE deleted_at IS NULL;
        
        RAISE NOTICE 'Created tenant-scoped unique constraint for reports.report_number';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not create tenant report_number constraint: %', SQLERRM;
END $$;

-- ============================================
-- STEP 4: ENSURE COMPANY-SCOPED UNIQUENESS FOR OTHER ENTITIES
-- ============================================

-- Create tenant-scoped constraints for API keys
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'api_keys' AND column_name = 'company_id'
    ) THEN
        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_api_keys_name_company_unique 
        ON api_keys (company_id, key_name) 
        WHERE deleted_at IS NULL;
        
        RAISE NOTICE 'Created tenant-scoped unique constraint for api_keys.key_name';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not create tenant api_key constraint: %', SQLERRM;
END $$;

-- Create tenant-scoped constraints for work orders
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'work_orders' AND column_name = 'company_id'
    ) AND EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'work_orders' AND column_name = 'work_order_number'
    ) THEN
        CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_work_orders_number_company_unique 
        ON work_orders (company_id, work_order_number) 
        WHERE deleted_at IS NULL;
        
        RAISE NOTICE 'Created tenant-scoped unique constraint for work_orders.work_order_number';
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Could not create tenant work_order constraint: %', SQLERRM;
END $$;

-- ============================================
-- STEP 5: CREATE TENANT VALIDATION TRIGGERS
-- ============================================

-- Create function to validate tenant consistency on insert/update
CREATE OR REPLACE FUNCTION validate_tenant_consistency()
RETURNS TRIGGER AS $$
DECLARE
    current_tenant_id UUID;
BEGIN
    -- Get current tenant from session
    current_tenant_id := NULLIF(current_setting('app.current_company_id', true), '')::UUID;
    
    -- Allow system operations (no tenant context)
    IF current_tenant_id IS NULL THEN
        RETURN COALESCE(NEW, OLD);
    END IF;
    
    -- For INSERT/UPDATE operations
    IF TG_OP IN ('INSERT', 'UPDATE') THEN
        -- Ensure company_id matches current tenant
        IF NEW.company_id IS NULL THEN
            NEW.company_id := current_tenant_id;
        ELSIF NEW.company_id != current_tenant_id THEN
            RAISE EXCEPTION 'Tenant isolation violation: Attempting to modify entity belonging to different tenant';
        END IF;
        RETURN NEW;
    END IF;
    
    -- For DELETE operations, validate ownership
    IF TG_OP = 'DELETE' THEN
        IF OLD.company_id != current_tenant_id THEN
            RAISE EXCEPTION 'Tenant isolation violation: Attempting to delete entity belonging to different tenant';
        END IF;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Apply tenant validation triggers to critical tables
DO $$
DECLARE
    table_name TEXT;
    critical_tables TEXT[] := ARRAY['users', 'reports', 'work_orders', 'schools', 'assets'];
BEGIN
    FOREACH table_name IN ARRAY critical_tables
    LOOP
        -- Check if table exists and has company_id
        IF EXISTS (
            SELECT 1 FROM information_schema.tables 
            WHERE table_name = table_name AND table_schema = 'public'
        ) AND EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = table_name AND column_name = 'company_id'
        ) THEN
            -- Drop existing trigger if it exists
            EXECUTE format('DROP TRIGGER IF EXISTS trg_validate_tenant_%s ON %I', table_name, table_name);
            
            -- Create new trigger
            EXECUTE format(
                'CREATE TRIGGER trg_validate_tenant_%s 
                 BEFORE INSERT OR UPDATE OR DELETE ON %I
                 FOR EACH ROW EXECUTE FUNCTION validate_tenant_consistency()', 
                 table_name, table_name
            );
            
            RAISE NOTICE 'Created tenant validation trigger for table %', table_name;
        END IF;
    END LOOP;
END $$;

-- ============================================
-- STEP 6: VALIDATE CONSTRAINT FIXES
-- ============================================

-- Test tenant-scoped uniqueness
DO $$
DECLARE
    test_company_1 UUID := '11111111-1111-1111-1111-111111111111';
    test_company_2 UUID := '22222222-2222-2222-2222-222222222222'; 
    constraint_count INTEGER;
BEGIN
    RAISE NOTICE '=== VALIDATING TENANT-SCOPED CONSTRAINTS ===';
    
    -- Count tenant-scoped unique indexes
    SELECT COUNT(*) INTO constraint_count
    FROM pg_indexes 
    WHERE schemaname = 'public' 
    AND indexname LIKE '%_company_unique';
    
    RAISE NOTICE 'Created % tenant-scoped unique constraints', constraint_count;
    
    -- Verify no global unique constraints remain on critical fields
    SELECT COUNT(*) INTO constraint_count
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu 
        ON tc.constraint_name = kcu.constraint_name
    WHERE tc.constraint_type = 'UNIQUE' 
    AND tc.table_schema = 'public'
    AND tc.table_name IN ('users', 'schools', 'reports')
    AND kcu.column_name IN ('email', 'username', 'employee_id', 'code', 'report_number')
    AND tc.constraint_name NOT LIKE '%company%';
    
    IF constraint_count = 0 THEN
        RAISE NOTICE 'SUCCESS: No problematic global unique constraints found';
    ELSE
        RAISE WARNING 'WARNING: Found % remaining global unique constraints', constraint_count;
    END IF;
    
END $$;

-- ============================================
-- STEP 7: CREATE MONITORING FUNCTIONS
-- ============================================

-- Function to check tenant isolation health
CREATE OR REPLACE FUNCTION check_tenant_isolation_health()
RETURNS TABLE (
    table_name TEXT,
    has_company_id BOOLEAN,
    has_tenant_constraint BOOLEAN,
    has_rls_policy BOOLEAN,
    isolation_score INTEGER
) AS $$
DECLARE
    tbl_name TEXT;
    critical_tables TEXT[] := ARRAY['users', 'reports', 'work_orders', 'schools', 'assets', 'api_keys'];
BEGIN
    FOREACH tbl_name IN ARRAY critical_tables
    LOOP
        SELECT 
            tbl_name,
            EXISTS (
                SELECT 1 FROM information_schema.columns 
                WHERE table_name = tbl_name AND column_name = 'company_id'
            ),
            EXISTS (
                SELECT 1 FROM pg_indexes 
                WHERE tablename = tbl_name AND indexname LIKE '%company_unique'
            ),
            EXISTS (
                SELECT 1 FROM pg_policies 
                WHERE tablename = tbl_name
            ),
            CASE 
                WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = tbl_name AND column_name = 'company_id')
                     AND EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = tbl_name AND indexname LIKE '%company_unique')
                     AND EXISTS (SELECT 1 FROM pg_policies WHERE tablename = tbl_name)
                THEN 100
                WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = tbl_name AND column_name = 'company_id')
                     AND EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = tbl_name AND indexname LIKE '%company_unique')
                THEN 75
                WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = tbl_name AND column_name = 'company_id')
                THEN 50
                ELSE 0
            END
        INTO table_name, has_company_id, has_tenant_constraint, has_rls_policy, isolation_score;
        
        RETURN NEXT;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- FINAL VALIDATION AND SUMMARY
-- ============================================

DO $$
DECLARE
    health_record RECORD;
    total_score INTEGER := 0;
    table_count INTEGER := 0;
BEGIN
    RAISE NOTICE '=== TENANT ISOLATION HEALTH REPORT ===';
    
    FOR health_record IN SELECT * FROM check_tenant_isolation_health()
    LOOP
        RAISE NOTICE 'Table %: Company_ID=%, Constraints=%, RLS=%, Score=%', 
                     health_record.table_name,
                     health_record.has_company_id,
                     health_record.has_tenant_constraint, 
                     health_record.has_rls_policy,
                     health_record.isolation_score;
                     
        total_score := total_score + health_record.isolation_score;
        table_count := table_count + 1;
    END LOOP;
    
    RAISE NOTICE '=== SUMMARY ===';
    RAISE NOTICE 'Overall tenant isolation health: %% (%/% tables)', 
                 (total_score::DECIMAL / (table_count * 100) * 100)::INTEGER,
                 table_count, table_count;
    
    IF (total_score::DECIMAL / (table_count * 100)) >= 0.75 THEN
        RAISE NOTICE 'SECURITY STATUS: GOOD - Multi-tenant constraints properly configured';
    ELSE
        RAISE WARNING 'SECURITY STATUS: NEEDS ATTENTION - Some tables lack proper tenant isolation';
    END IF;
END $$;

-- End of migration
RAISE NOTICE '=== MULTI-TENANT CONSTRAINT FIX COMPLETED ===';
RAISE NOTICE 'Global unique constraints replaced with tenant-scoped constraints';
RAISE NOTICE 'Tenant validation triggers installed on critical tables';
RAISE NOTICE 'Run SELECT * FROM check_tenant_isolation_health() to monitor isolation health';