-- V134: Create Work Order Materials Table  
-- Purpose: Creates work_order_materials table for tracking material usage in work orders
-- Pattern: Follows existing migration patterns with multi-tenant isolation and inventory integration
-- Java 23: Supports enhanced work order cost tracking and inventory management
-- Architecture: Links work order system with inventory management for material consumption
-- Standards: Includes audit columns, soft delete, and proper cost tracking

-- Create work_order_materials table
CREATE TABLE work_order_materials (
    -- Primary identification
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Work order association (can be work order or specific task)
    work_order_id UUID,
    task_id UUID,
    
    -- Company isolation (multi-tenant)
    company_id UUID NOT NULL,
    
    -- Inventory item reference (optional - for tracked inventory)
    inventory_item_id UUID,
    
    -- Material identification (for both tracked and untracked materials)
    material_code VARCHAR(50),
    material_name VARCHAR(255) NOT NULL,
    material_description TEXT,
    material_category VARCHAR(100),
    
    -- Material specifications
    manufacturer VARCHAR(100),
    model_number VARCHAR(100),
    part_number VARCHAR(100),
    material_type VARCHAR(50) DEFAULT 'CONSUMABLE',
    
    -- Quantity tracking
    quantity_requested DECIMAL(10,3) NOT NULL DEFAULT 0 CHECK (quantity_requested >= 0),
    quantity_allocated DECIMAL(10,3) DEFAULT 0 CHECK (quantity_allocated >= 0),
    quantity_used DECIMAL(10,3) DEFAULT 0 CHECK (quantity_used >= 0),
    quantity_returned DECIMAL(10,3) DEFAULT 0 CHECK (quantity_returned >= 0),
    quantity_wasted DECIMAL(10,3) DEFAULT 0 CHECK (quantity_wasted >= 0),
    
    -- Unit information
    unit_of_measure VARCHAR(20) NOT NULL DEFAULT 'EACH',
    unit_cost DECIMAL(10,2) DEFAULT 0 CHECK (unit_cost >= 0),
    total_cost DECIMAL(10,2) GENERATED ALWAYS AS (quantity_used * unit_cost) STORED,
    
    -- Procurement information
    supplier VARCHAR(255),
    purchase_order_number VARCHAR(50),
    expected_delivery_date DATE,
    actual_delivery_date DATE,
    
    -- Material status tracking
    status VARCHAR(30) DEFAULT 'REQUESTED',
    requisition_number VARCHAR(50),
    
    -- Allocation and reservation
    allocated_from_location VARCHAR(100),
    allocated_by UUID,
    allocation_date TIMESTAMP WITH TIME ZONE,
    reservation_id UUID,
    
    -- Usage tracking
    used_by UUID,
    usage_date TIMESTAMP WITH TIME ZONE,
    usage_location VARCHAR(100),
    usage_notes TEXT,
    
    -- Return tracking
    returned_by UUID,
    return_date TIMESTAMP WITH TIME ZONE,
    return_condition VARCHAR(50) DEFAULT 'GOOD',
    return_reason TEXT,
    
    -- Waste tracking
    waste_reason VARCHAR(100),
    waste_date TIMESTAMP WITH TIME ZONE,
    waste_reported_by UUID,
    
    -- Quality and compliance
    batch_number VARCHAR(50),
    serial_numbers JSONB DEFAULT '[]'::jsonb,
    expiry_date DATE,
    quality_check_required BOOLEAN DEFAULT false,
    quality_check_passed BOOLEAN,
    quality_checked_by UUID,
    quality_check_date TIMESTAMP WITH TIME ZONE,
    quality_notes TEXT,
    
    -- Safety and handling
    is_hazardous BOOLEAN DEFAULT false,
    safety_data_sheet_url TEXT,
    handling_instructions TEXT,
    disposal_instructions TEXT,
    
    -- Warranty and maintenance
    warranty_period_months INTEGER,
    warranty_start_date DATE,
    maintenance_required BOOLEAN DEFAULT false,
    maintenance_interval_days INTEGER,
    next_maintenance_date DATE,
    
    -- Cost center and billing
    cost_center VARCHAR(50),
    project_code VARCHAR(50),
    billing_category VARCHAR(50) DEFAULT 'MATERIAL',
    is_billable_to_customer BOOLEAN DEFAULT false,
    customer_charge_rate DECIMAL(10,2),
    
    -- Approval workflow
    approval_required BOOLEAN DEFAULT false,
    approval_status VARCHAR(30) DEFAULT 'APPROVED',
    approved_by UUID,
    approval_date TIMESTAMP WITH TIME ZONE,
    approval_notes TEXT,
    
    -- Additional metadata
    priority VARCHAR(20) DEFAULT 'NORMAL',
    urgency VARCHAR(20) DEFAULT 'NORMAL',
    tags JSONB DEFAULT '[]'::jsonb,
    custom_fields JSONB DEFAULT '{}'::jsonb,
    
    -- Audit columns
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by UUID,
    updated_by UUID,
    
    -- Soft delete
    deleted_at TIMESTAMP WITH TIME ZONE,
    deleted_by UUID,
    
    -- Constraints
    CONSTRAINT chk_material_association CHECK (
        (work_order_id IS NOT NULL AND task_id IS NULL) OR
        (work_order_id IS NULL AND task_id IS NOT NULL)
    ),
    CONSTRAINT chk_quantity_logic CHECK (
        quantity_used <= (quantity_allocated + quantity_requested) AND
        quantity_returned <= quantity_used AND
        (quantity_used + quantity_returned + quantity_wasted) <= (quantity_allocated + quantity_requested)
    ),
    CONSTRAINT chk_dates_logical CHECK (
        (expected_delivery_date IS NULL OR actual_delivery_date IS NULL OR actual_delivery_date >= expected_delivery_date) AND
        (allocation_date IS NULL OR usage_date IS NULL OR usage_date >= allocation_date) AND
        (usage_date IS NULL OR return_date IS NULL OR return_date >= usage_date)
    ),
    
    -- Foreign key constraints
    CONSTRAINT fk_work_order_materials_work_order 
        FOREIGN KEY (work_order_id) REFERENCES work_orders(id) ON DELETE CASCADE,
    CONSTRAINT fk_work_order_materials_task 
        FOREIGN KEY (task_id) REFERENCES work_order_tasks(id) ON DELETE CASCADE,
    CONSTRAINT fk_work_order_materials_company 
        FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE CASCADE,
    CONSTRAINT fk_work_order_materials_inventory_item 
        FOREIGN KEY (inventory_item_id) REFERENCES inventory_items(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_allocated_by 
        FOREIGN KEY (allocated_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_used_by 
        FOREIGN KEY (used_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_returned_by 
        FOREIGN KEY (returned_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_waste_reported_by 
        FOREIGN KEY (waste_reported_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_quality_checked_by 
        FOREIGN KEY (quality_checked_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_approved_by 
        FOREIGN KEY (approved_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_created_by 
        FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_updated_by 
        FOREIGN KEY (updated_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT fk_work_order_materials_deleted_by 
        FOREIGN KEY (deleted_by) REFERENCES users(id) ON DELETE SET NULL
);

-- Create enums for material management
DO $$
BEGIN
    -- Material type enum
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'material_type') THEN
        CREATE TYPE material_type AS ENUM (
            'CONSUMABLE',
            'SPARE_PART',
            'TOOL',
            'CHEMICAL',
            'ELECTRICAL',
            'PLUMBING',
            'HVAC',
            'SAFETY',
            'CLEANING',
            'FASTENER',
            'RAW_MATERIAL',
            'COMPONENT',
            'OTHER'
        );
    END IF;
    
    -- Material status enum
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'material_status') THEN
        CREATE TYPE material_status AS ENUM (
            'REQUESTED',
            'REQUISITIONED',
            'ORDERED',
            'ALLOCATED', 
            'RESERVED',
            'IN_TRANSIT',
            'DELIVERED',
            'USED',
            'RETURNED',
            'CANCELLED',
            'EXPIRED'
        );
    END IF;
    
    -- Return condition enum
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'return_condition') THEN
        CREATE TYPE return_condition AS ENUM (
            'EXCELLENT',
            'GOOD',
            'FAIR',
            'POOR',
            'DAMAGED',
            'UNUSABLE'
        );
    END IF;
    
    -- Priority enum (if not exists)
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'material_priority') THEN
        CREATE TYPE material_priority AS ENUM (
            'LOW',
            'NORMAL',
            'HIGH',
            'URGENT',
            'EMERGENCY'
        );
    END IF;
END$$;

-- Update columns to use enums
ALTER TABLE work_order_materials 
    ALTER COLUMN material_type TYPE material_type USING material_type::material_type,
    ALTER COLUMN status TYPE material_status USING status::material_status,
    ALTER COLUMN return_condition TYPE return_condition USING return_condition::return_condition,
    ALTER COLUMN priority TYPE material_priority USING priority::material_priority,
    ALTER COLUMN urgency TYPE material_priority USING urgency::material_priority,
    ALTER COLUMN approval_status TYPE approval_status USING approval_status::approval_status;

-- Create performance indexes
CREATE INDEX idx_work_order_materials_work_order_id 
    ON work_order_materials(work_order_id) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_task_id 
    ON work_order_materials(task_id) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_company_id 
    ON work_order_materials(company_id) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_inventory_item_id 
    ON work_order_materials(inventory_item_id) WHERE deleted_at IS NULL AND inventory_item_id IS NOT NULL;

CREATE INDEX idx_work_order_materials_status 
    ON work_order_materials(status) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_material_code 
    ON work_order_materials(material_code) WHERE deleted_at IS NULL AND material_code IS NOT NULL;

CREATE INDEX idx_work_order_materials_supplier 
    ON work_order_materials(supplier) WHERE deleted_at IS NULL AND supplier IS NOT NULL;

CREATE INDEX idx_work_order_materials_cost_tracking 
    ON work_order_materials(unit_cost, total_cost) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_delivery_dates 
    ON work_order_materials(expected_delivery_date, actual_delivery_date) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_expiry 
    ON work_order_materials(expiry_date) WHERE deleted_at IS NULL AND expiry_date IS NOT NULL;

CREATE INDEX idx_work_order_materials_hazardous 
    ON work_order_materials(is_hazardous) WHERE deleted_at IS NULL AND is_hazardous = true;

CREATE INDEX idx_work_order_materials_approval 
    ON work_order_materials(approval_status) WHERE deleted_at IS NULL AND approval_required = true;

-- Create composite indexes for common queries
CREATE INDEX idx_work_order_materials_wo_status 
    ON work_order_materials(work_order_id, status) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_company_status 
    ON work_order_materials(company_id, status) WHERE deleted_at IS NULL;

-- Create GIN indexes for JSONB fields
CREATE INDEX idx_work_order_materials_serial_numbers 
    ON work_order_materials USING gin(serial_numbers) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_tags 
    ON work_order_materials USING gin(tags) WHERE deleted_at IS NULL;

CREATE INDEX idx_work_order_materials_custom_fields 
    ON work_order_materials USING gin(custom_fields) WHERE deleted_at IS NULL;

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_work_order_materials_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_work_order_materials_updated_at
    BEFORE UPDATE ON work_order_materials
    FOR EACH ROW
    EXECUTE FUNCTION update_work_order_materials_updated_at();

-- Create multi-tenant RLS policy
ALTER TABLE work_order_materials ENABLE ROW LEVEL SECURITY;

CREATE POLICY work_order_materials_tenant_isolation ON work_order_materials
    FOR ALL
    TO PUBLIC
    USING (company_id = current_setting('app.current_company_id', true)::uuid)
    WITH CHECK (company_id = current_setting('app.current_company_id', true)::uuid);

-- Create view for material usage summary
CREATE VIEW work_order_materials_summary AS
SELECT 
    wom.*,
    wo.work_order_number,
    wo.title as work_order_title,
    wot.task_number,
    wot.title as task_title,
    ii.item_code as inventory_item_code,
    ii.current_quantity as inventory_available,
    allocator.first_name || ' ' || allocator.last_name as allocated_by_name,
    user_used.first_name || ' ' || user_used.last_name as used_by_name,
    approver.first_name || ' ' || approver.last_name as approved_by_name,
    (CASE 
        WHEN wom.expiry_date IS NOT NULL AND wom.expiry_date < CURRENT_DATE 
        THEN true 
        ELSE false 
    END) as is_expired,
    (CASE 
        WHEN wom.expiry_date IS NOT NULL AND wom.expiry_date <= (CURRENT_DATE + INTERVAL '30 days')
        THEN true 
        ELSE false 
    END) as expires_soon,
    (wom.quantity_allocated - wom.quantity_used - wom.quantity_returned) as quantity_remaining
FROM work_order_materials wom
LEFT JOIN work_orders wo ON wo.id = wom.work_order_id
LEFT JOIN work_order_tasks wot ON wot.id = wom.task_id
LEFT JOIN inventory_items ii ON ii.id = wom.inventory_item_id
LEFT JOIN users allocator ON allocator.id = wom.allocated_by
LEFT JOIN users user_used ON user_used.id = wom.used_by
LEFT JOIN users approver ON approver.id = wom.approved_by
WHERE wom.deleted_at IS NULL;

-- Create function to calculate material costs for work order
CREATE OR REPLACE FUNCTION calculate_work_order_material_cost(p_work_order_id UUID)
RETURNS DECIMAL(10,2) AS $$
DECLARE
    total_cost DECIMAL(10,2) := 0;
BEGIN
    SELECT COALESCE(SUM(total_cost), 0) INTO total_cost
    FROM work_order_materials
    WHERE work_order_id = p_work_order_id 
      AND deleted_at IS NULL;
    
    RETURN total_cost;
END;
$$ LANGUAGE plpgsql;

-- Create function to check material availability
CREATE OR REPLACE FUNCTION check_material_availability(p_inventory_item_id UUID, p_required_quantity DECIMAL(10,3))
RETURNS BOOLEAN AS $$
DECLARE
    available_quantity DECIMAL(10,3) := 0;
    reserved_quantity DECIMAL(10,3) := 0;
    actual_available DECIMAL(10,3) := 0;
BEGIN
    -- Get current inventory
    SELECT current_quantity, COALESCE(reserved_quantity, 0) 
    INTO available_quantity, reserved_quantity
    FROM inventory_items
    WHERE id = p_inventory_item_id AND deleted_at IS NULL;
    
    -- Calculate actual available (current - reserved)
    actual_available := COALESCE(available_quantity, 0) - COALESCE(reserved_quantity, 0);
    
    RETURN actual_available >= p_required_quantity;
END;
$$ LANGUAGE plpgsql;

-- Add helpful comments
COMMENT ON TABLE work_order_materials IS 'Materials and parts used in work orders with full lifecycle tracking';
COMMENT ON COLUMN work_order_materials.total_cost IS 'Generated column: quantity_used * unit_cost';
COMMENT ON COLUMN work_order_materials.serial_numbers IS 'JSON array of serial numbers for tracked items';
COMMENT ON COLUMN work_order_materials.quality_check_required IS 'Whether material requires quality inspection before use';
COMMENT ON COLUMN work_order_materials.is_hazardous IS 'Whether material requires special handling procedures';
COMMENT ON COLUMN work_order_materials.waste_reason IS 'Reason for material waste (damaged, expired, spillage, etc.)';

-- Grant appropriate permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON work_order_materials TO cafm_app_role;
GRANT SELECT ON work_order_materials_summary TO cafm_app_role;
GRANT EXECUTE ON FUNCTION calculate_work_order_material_cost(UUID) TO cafm_app_role;
GRANT EXECUTE ON FUNCTION check_material_availability(UUID, DECIMAL) TO cafm_app_role;
GRANT EXECUTE ON FUNCTION update_work_order_materials_updated_at() TO cafm_app_role;