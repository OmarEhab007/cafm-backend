package com.cafm.cafmbackend.domain.services;

import com.cafm.cafmbackend.api.mappers.WorkOrderMapper;
import com.cafm.cafmbackend.data.entity.*;
import com.cafm.cafmbackend.data.enums.WorkOrderStatus;
import com.cafm.cafmbackend.data.enums.UserType;
import com.cafm.cafmbackend.data.enums.WorkOrderPriority;
import com.cafm.cafmbackend.data.repository.*;
import com.cafm.cafmbackend.dto.workorder.*;
import com.cafm.cafmbackend.exception.EntityNotFoundException;
import com.cafm.cafmbackend.exception.BusinessValidationException;
import com.cafm.cafmbackend.security.TenantContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

/**
 * Work Order service for managing maintenance work assignments.
 * 
 * Purpose: Manages work order lifecycle from creation to completion with assignment logic
 * Pattern: Service layer with repository pattern and business logic encapsulation
 * Java 23: Leverages pattern matching and enhanced data processing
 * Architecture: Domain service with transaction management and audit logging
 * Standards: Constructor injection, comprehensive validation, assignment optimization
 */
@Service
@Transactional(readOnly = true)
public class WorkOrderService {

    private static final Logger logger = LoggerFactory.getLogger(WorkOrderService.class);
    private static final Logger auditLogger = LoggerFactory.getLogger("com.cafm.cafmbackend.security");

    private final WorkOrderRepository workOrderRepository;
    private final UserRepository userRepository;
    private final CompanyRepository companyRepository;
    private final SchoolRepository schoolRepository;
    private final ReportRepository reportRepository;
    private final WorkOrderMapper workOrderMapper;
    private final NotificationService notificationService;

    public WorkOrderService(WorkOrderRepository workOrderRepository,
                           UserRepository userRepository,
                           CompanyRepository companyRepository,
                           SchoolRepository schoolRepository,
                           ReportRepository reportRepository,
                           WorkOrderMapper workOrderMapper,
                           NotificationService notificationService) {
        this.workOrderRepository = workOrderRepository;
        this.userRepository = userRepository;
        this.companyRepository = companyRepository;
        this.schoolRepository = schoolRepository;
        this.reportRepository = reportRepository;
        this.workOrderMapper = workOrderMapper;
        this.notificationService = notificationService;
    }

    // ========== Create Operations ==========

    /**
     * Create a new work order with automatic assignment logic.
     * 
     * @param request Work order creation request
     * @return Created work order response
     * @throws BusinessValidationException if work order data is invalid
     * @throws EntityNotFoundException if related entities not found
     */
    @Transactional
    public WorkOrderResponse createWorkOrder(WorkOrderCreateRequest request) {
        logger.debug("Creating work order for report: {}", request.reportId());
        
        // Get tenant company and validate entities
        Company company = getTenantCompany();
        Report report = getReportById(request.reportId());
        School school = report.getSchool(); // Work order inherits school from report
        
        // Create and populate work order entity
        WorkOrder workOrder = workOrderMapper.toEntity(request);
        workOrder.setCompany(company);
        workOrder.setSchool(school);
        workOrder.setReport(report);
        workOrder.setStatus(WorkOrderStatus.CREATED);
        workOrder.setWorkOrderNumber(generateWorkOrderNumber(company, school));
        
        // Set priority based on report if not specified
        if (workOrder.getPriority() == null) {
            workOrder.setPriority(mapReportPriorityToWorkOrder(report.getPriority()));
        }
        
        // Handle assignment - check if direct assignment or auto-assignment requested
        if (request.assignedToId() != null) {
            User assignedTechnician = getUserById(request.assignedToId());
            workOrder.setAssignedTo(assignedTechnician);
            workOrder.setAssignedAt(LocalDateTime.now());
            workOrder.setStatus(WorkOrderStatus.ASSIGNED);
        } else if (request.notifyTechnician() != null && request.notifyTechnician()) {
            // Auto-assign logic could be implemented here
            User assignedTechnician = findBestAvailableTechnician(workOrder);
            if (assignedTechnician != null) {
                workOrder.setAssignedTo(assignedTechnician);
                workOrder.setAssignedAt(LocalDateTime.now());
                workOrder.setStatus(WorkOrderStatus.ASSIGNED);
            }
        }
        
        // Save work order
        WorkOrder savedWorkOrder = workOrderRepository.save(workOrder);
        
        // Send notifications
        sendWorkOrderCreatedNotifications(savedWorkOrder);
        
        // Audit log
        auditLogger.info("Work order created - ID: {}, Number: {}, Report: {}, School: {}, Company: {}", 
                        savedWorkOrder.getId(), savedWorkOrder.getWorkOrderNumber(), 
                        report.getId(), school.getName(), company.getId());
        
        return workOrderMapper.toResponse(savedWorkOrder);
    }

    /**
     * Create work order from report automatically.
     * 
     * @param reportId Report to create work order from
     * @return Created work order
     */
    @Transactional
    public WorkOrderResponse createWorkOrderFromReport(UUID reportId) {
        logger.debug("Creating work order from report: {}", reportId);
        
        Report report = getReportById(reportId);
        
        // Check if work order already exists for this report
        Optional<WorkOrder> existingWorkOrder = workOrderRepository.findAll().stream()
                .filter(wo -> wo.getReport().getId().equals(reportId) && wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .findFirst();
        
        if (existingWorkOrder.isPresent()) {
            throw new BusinessValidationException("Work order already exists for report: " + report.getReportNumber());
        }
        
        // Create work order request from report
        LocalDateTime scheduledStart = report.getScheduledDate() != null ? 
            report.getScheduledDate().atTime(8, 0) : LocalDateTime.now().plusHours(2);
        LocalDateTime scheduledEnd = scheduledStart.plusHours(4); // Default 4-hour window
        
        WorkOrderCreateRequest request = WorkOrderCreateRequest.fromReport(
            reportId,
            report.getTitle(),
            report.getDescription(),
            mapReportPriorityToWorkOrder(report.getPriority()),
            "maintenance", // category
            scheduledStart,
            scheduledEnd,
            null // estimatedCost
        );
        
        return createWorkOrder(request);
    }

    // ========== Read Operations ==========

    /**
     * Get work order by ID with full details.
     */
    public WorkOrderResponse getWorkOrderById(UUID workOrderId) {
        logger.debug("Retrieving work order by ID: {}", workOrderId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
                
        return workOrderMapper.toResponse(workOrder);
    }

    /**
     * Get work order by number within tenant.
     */
    public Optional<WorkOrderResponse> getWorkOrderByNumber(String workOrderNumber) {
        logger.debug("Retrieving work order by number: {}", workOrderNumber);
        
        return workOrderRepository.findAll().stream()
                .filter(wo -> wo.getWorkOrderNumber().equals(workOrderNumber) && wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .map(workOrderMapper::toResponse)
                .findFirst();
    }

    /**
     * Get all work orders with pagination and filtering.
     */
    public Page<WorkOrderListResponse> getWorkOrders(Specification<WorkOrder> spec, Pageable pageable) {
        logger.debug("Retrieving work orders with pagination - Page: {}, Size: {}", 
                    pageable.getPageNumber(), pageable.getPageSize());
        
        // Add tenant filter to specification
        Specification<WorkOrder> tenantSpec = addTenantFilter(spec);
        
        Page<WorkOrder> workOrders = workOrderRepository.findAll(tenantSpec, pageable);
        return workOrders.map(workOrderMapper::toListResponse);
    }

    /**
     * Get work orders by school.
     */
    public List<WorkOrderListResponse> getWorkOrdersBySchool(UUID schoolId) {
        logger.debug("Retrieving work orders for school: {}", schoolId);
        
        // Validate school exists and belongs to tenant
        School school = getSchoolById(schoolId);
        
        List<WorkOrder> workOrders = workOrderRepository.findAll().stream()
                .filter(wo -> wo.getSchool().getId().equals(schoolId) && wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .toList();
        
        return workOrders.stream()
                .map(workOrderMapper::toListResponse)
                .toList();
    }

    /**
     * Get work orders assigned to technician.
     */
    public List<WorkOrderListResponse> getWorkOrdersByTechnician(UUID technicianId) {
        logger.debug("Retrieving work orders for technician: {}", technicianId);
        
        // Validate technician exists and belongs to tenant
        User technician = getUserById(technicianId);
        
        List<WorkOrder> workOrders = workOrderRepository.findAll().stream()
                .filter(wo -> wo.getAssignedTo() != null && wo.getAssignedTo().getId().equals(technicianId) && wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .toList();
        
        return workOrders.stream()
                .map(workOrderMapper::toListResponse)
                .toList();
    }

    /**
     * Get work orders by status.
     */
    public List<WorkOrderListResponse> getWorkOrdersByStatus(WorkOrderStatus status) {
        logger.debug("Retrieving work orders by status: {}", status);
        
        List<WorkOrder> workOrders = workOrderRepository.findAll().stream()
                .filter(wo -> wo.getStatus() == status && wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .toList();
        
        return workOrders.stream()
                .map(workOrderMapper::toListResponse)
                .toList();
    }

    // ========== Update Operations ==========

    /**
     * Update work order information.
     */
    @Transactional
    public WorkOrderResponse updateWorkOrder(UUID workOrderId, WorkOrderUpdateRequest request) {
        logger.debug("Updating work order: {}", workOrderId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
        
        // Update work order fields
        workOrderMapper.updateEntity(workOrder, request);
        
        WorkOrder savedWorkOrder = workOrderRepository.save(workOrder);
        
        auditLogger.info("Work order updated - ID: {}, Number: {}", savedWorkOrder.getId(), savedWorkOrder.getWorkOrderNumber());
        
        return workOrderMapper.toResponse(savedWorkOrder);
    }

    // ========== Assignment Operations ==========

    /**
     * Assign work order to technician.
     */
    @Transactional
    public WorkOrderResponse assignWorkOrder(UUID workOrderId, UUID technicianId, String notes) {
        logger.debug("Assigning work order {} to technician: {}", workOrderId, technicianId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
        
        User technician = getUserById(technicianId);
        
        // Validate technician can be assigned
        if (technician.getUserType() != UserType.TECHNICIAN) {
            throw new BusinessValidationException("User is not a technician: " + technician.getEmail());
        }
        
        if (!technician.isActive()) {
            throw new BusinessValidationException("Technician is not active: " + technician.getEmail());
        }
        
        // Update work order
        workOrder.setAssignedTo(technician);
        workOrder.setAssignedAt(LocalDateTime.now());
        workOrder.setStatus(WorkOrderStatus.ASSIGNED);
        
        WorkOrder savedWorkOrder = workOrderRepository.save(workOrder);
        
        // Send notification to technician
        notificationService.notifyWorkOrderAssigned(savedWorkOrder, technician);
        
        auditLogger.info("Work order assigned - ID: {}, Technician: {}, Notes: {}", 
                        workOrderId, technician.getEmail(), notes);
        
        return workOrderMapper.toResponse(savedWorkOrder);
    }

    /**
     * Auto-assign work order to best available technician.
     */
    @Transactional
    public WorkOrderResponse autoAssignWorkOrder(UUID workOrderId) {
        logger.debug("Auto-assigning work order: {}", workOrderId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
        
        if (workOrder.getAssignedTo() != null) {
            throw new BusinessValidationException("Work order is already assigned: " + workOrder.getWorkOrderNumber());
        }
        
        User bestTechnician = findBestAvailableTechnician(workOrder);
        if (bestTechnician == null) {
            throw new BusinessValidationException("No available technicians found for work order: " + workOrder.getWorkOrderNumber());
        }
        
        return assignWorkOrder(workOrderId, bestTechnician.getId(), "Auto-assigned by system");
    }

    /**
     * Unassign work order from technician.
     */
    @Transactional
    public WorkOrderResponse unassignWorkOrder(UUID workOrderId, String reason) {
        logger.debug("Unassigning work order: {}", workOrderId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
        
        if (workOrder.getAssignedTo() == null) {
            throw new BusinessValidationException("Work order is not assigned: " + workOrder.getWorkOrderNumber());
        }
        
        User previousTechnician = workOrder.getAssignedTo();
        workOrder.setAssignedTo(null);
        workOrder.setAssignedAt(null);
        workOrder.setStatus(WorkOrderStatus.CREATED);
        
        WorkOrder savedWorkOrder = workOrderRepository.save(workOrder);
        
        auditLogger.info("Work order unassigned - ID: {}, Previous technician: {}, Reason: {}", 
                        workOrderId, previousTechnician.getEmail(), reason);
        
        return workOrderMapper.toResponse(savedWorkOrder);
    }

    // ========== Status Management ==========

    /**
     * Start work order (move to IN_PROGRESS).
     */
    @Transactional
    public WorkOrderResponse startWorkOrder(UUID workOrderId, String notes) {
        logger.debug("Starting work order: {}", workOrderId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
        
        validateStatusTransition(workOrder, WorkOrderStatus.IN_PROGRESS);
        
        workOrder.setStatus(WorkOrderStatus.IN_PROGRESS);
        workOrder.setStartedAt(LocalDateTime.now());
        
        WorkOrder savedWorkOrder = workOrderRepository.save(workOrder);
        
        auditLogger.info("Work order started - ID: {}, Notes: {}", workOrderId, notes);
        
        return workOrderMapper.toResponse(savedWorkOrder);
    }

    /**
     * Complete work order.
     */
    @Transactional
    public WorkOrderResponse completeWorkOrder(UUID workOrderId, WorkOrderCompletionRequest request) {
        logger.debug("Completing work order: {}", workOrderId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
        
        validateStatusTransition(workOrder, WorkOrderStatus.COMPLETED);
        
        // Update work order completion details
        workOrder.setStatus(WorkOrderStatus.COMPLETED);
        workOrder.setCompletedAt(LocalDateTime.now());
        workOrder.setCompletionNotes(request.completionNotes());
        
        if (request.actualCost() != null) {
            workOrder.setActualCost(request.actualCost());
        }
        
        WorkOrder savedWorkOrder = workOrderRepository.save(workOrder);
        
        auditLogger.info("Work order completed - ID: {}, Cost: {}", workOrderId, request.actualCost());
        
        return workOrderMapper.toResponse(savedWorkOrder);
    }

    /**
     * Cancel work order.
     */
    @Transactional
    public WorkOrderResponse cancelWorkOrder(UUID workOrderId, String reason) {
        logger.debug("Canceling work order: {}", workOrderId);
        
        WorkOrder workOrder = workOrderRepository.findById(workOrderId)
                .filter(wo -> wo.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("WorkOrder", workOrderId));
        
        validateStatusTransition(workOrder, WorkOrderStatus.CANCELLED);
        
        workOrder.setStatus(WorkOrderStatus.CANCELLED);
        workOrder.setCancellationReason(reason);
        workOrder.setCancelledAt(LocalDateTime.now());
        
        WorkOrder savedWorkOrder = workOrderRepository.save(workOrder);
        
        auditLogger.info("Work order cancelled - ID: {}, Reason: {}", workOrderId, reason);
        
        return workOrderMapper.toResponse(savedWorkOrder);
    }

    // ========== Statistics and Analytics ==========

    /**
     * Get work order statistics for dashboard.
     */
    public WorkOrderStatistics getWorkOrderStatistics() {
        logger.debug("Calculating work order statistics");
        
        UUID companyId = TenantContext.getCurrentCompanyId();
        
        // Simplified statistics using basic counts
        long totalWorkOrders = workOrderRepository.findAll().stream()
                .filter(wo -> wo.getCompany().getId().equals(companyId))
                .count();
        long assignedWorkOrders = 0; // Simplified
        long inProgressWorkOrders = 0; // Simplified  
        long completedWorkOrders = 0; // Simplified
        long overdueWorkOrders = 0; // Simplified
        
        // Simplified average completion time
        double avgCompletionDays = 0.0;
        
        return new WorkOrderStatistics(totalWorkOrders, assignedWorkOrders, inProgressWorkOrders,
                                     completedWorkOrders, overdueWorkOrders, avgCompletionDays);
    }

    // ========== Private Helper Methods ==========

    /**
     * Find best available technician for work order assignment.
     */
    private User findBestAvailableTechnician(WorkOrder workOrder) {
        logger.debug("Finding best technician for work order: {}", workOrder.getId());
        
        // Get all active technicians in the company
        List<User> availableTechnicians = userRepository.findAll().stream()
                .filter(u -> u.getUserType() == UserType.TECHNICIAN && 
                           u.isActive() && 
                           u.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .toList();
        
        if (availableTechnicians.isEmpty()) {
            return null;
        }
        
        // Simple assignment logic - return first available technician
        // In Phase 3, this would include workload balancing, skill matching, location proximity
        return availableTechnicians.get(0);
    }

    /**
     * Validate status transition according to workflow rules.
     */
    private void validateStatusTransition(WorkOrder workOrder, WorkOrderStatus newStatus) {
        WorkOrderStatus currentStatus = workOrder.getStatus();
        
        boolean isValidTransition = switch (currentStatus) {
            case CREATED -> newStatus == WorkOrderStatus.ASSIGNED || newStatus == WorkOrderStatus.CANCELLED;
            case ASSIGNED -> newStatus == WorkOrderStatus.IN_PROGRESS || newStatus == WorkOrderStatus.CANCELLED;
            case IN_PROGRESS -> newStatus == WorkOrderStatus.COMPLETED || newStatus == WorkOrderStatus.ON_HOLD || newStatus == WorkOrderStatus.CANCELLED;
            case ON_HOLD -> newStatus == WorkOrderStatus.IN_PROGRESS || newStatus == WorkOrderStatus.CANCELLED;
            case COMPLETED, CANCELLED -> false; // Final states
        };
        
        if (!isValidTransition) {
            throw new BusinessValidationException(
                String.format("Invalid status transition from %s to %s", currentStatus, newStatus));
        }
    }

    /**
     * Map report priority to work order priority.
     */
    private WorkOrderPriority mapReportPriorityToWorkOrder(com.cafm.cafmbackend.data.enums.ReportPriority reportPriority) {
        return switch (reportPriority) {
            case LOW -> WorkOrderPriority.LOW;
            case MEDIUM -> WorkOrderPriority.MEDIUM;
            case HIGH -> WorkOrderPriority.HIGH;
            case URGENT -> WorkOrderPriority.HIGH;
            case CRITICAL -> WorkOrderPriority.EMERGENCY;
        };
    }

    /**
     * Send notifications when work order is created.
     */
    private void sendWorkOrderCreatedNotifications(WorkOrder workOrder) {
        CompletableFuture.runAsync(() -> {
            try {
                // Notify assigned technician if assigned
                if (workOrder.getAssignedTo() != null) {
                    notificationService.notifyWorkOrderAssigned(workOrder, workOrder.getAssignedTo());
                }
                
                // Notify supervisor
                if (workOrder.getReport().getSupervisor() != null) {
                    // Would implement supervisor notification
                }
            } catch (Exception e) {
                logger.warn("Failed to send work order creation notifications", e);
            }
        });
    }

    /**
     * Get tenant company.
     */
    private Company getTenantCompany() {
        UUID companyId = TenantContext.getCurrentCompanyId();
        return companyRepository.findById(companyId)
                .orElseThrow(() -> new EntityNotFoundException("Company", companyId));
    }

    /**
     * Get report by ID with tenant validation.
     */
    private Report getReportById(UUID reportId) {
        return reportRepository.findById(reportId)
                .filter(report -> report.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("Report", reportId));
    }

    /**
     * Get school by ID with tenant validation.
     */
    private School getSchoolById(UUID schoolId) {
        return schoolRepository.findById(schoolId)
                .filter(school -> school.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("School", schoolId));
    }

    /**
     * Get user by ID with tenant validation.
     */
    private User getUserById(UUID userId) {
        return userRepository.findById(userId)
                .filter(user -> user.getCompany().getId().equals(TenantContext.getCurrentCompanyId()))
                .orElseThrow(() -> new EntityNotFoundException("User", userId));
    }

    /**
     * Generate unique work order number.
     */
    private String generateWorkOrderNumber(Company company, School school) {
        String prefix = (school.getName() != null ? school.getName().substring(0, Math.min(3, school.getName().length())).toUpperCase() : "SCH") + "-WO-";
        String year = String.valueOf(LocalDate.now().getYear());
        long workOrderCount = workOrderRepository.findAll().stream()
                .filter(wo -> wo.getCompany().getId().equals(company.getId()))
                .count();
        return prefix + year + "-" + String.format("%05d", workOrderCount + 1);
    }

    /**
     * Add tenant filter to specification.
     */
    private Specification<WorkOrder> addTenantFilter(Specification<WorkOrder> spec) {
        Specification<WorkOrder> tenantSpec = (root, query, criteriaBuilder) -> 
                criteriaBuilder.equal(root.get("company").get("id"), TenantContext.getCurrentCompanyId());
        
        if (spec != null) {
            return Specification.where(tenantSpec).and(spec);
        } else {
            return tenantSpec;
        }
    }

    /**
     * Work order statistics record for dashboard display.
     */
    public record WorkOrderStatistics(
        long totalWorkOrders,
        long assignedWorkOrders,
        long inProgressWorkOrders,
        long completedWorkOrders,
        long overdueWorkOrders,
        double averageCompletionDays
    ) {}
}